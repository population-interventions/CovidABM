
to simul_setContactsKnown
  ;; Allow contacts to be tracked now that this case is tracked.
  set hasKnownContact true
  ask turtle-set (table:values infectedContactList) [
    if traceAttempts > trace_attempt_limit / 2 [
      set traceAttempts 0
      set selfTraceEffMult selfTraceEffMult * 2 / 3
    ]
    if not hasKnownContact [
      set hasKnownContact true
      set knownContactTime ticks
      set traceAttempts 0
      set selfTraceEffMult 1
    ]
  ]
end

to simul_fixInfectedContactList
  ;; Remove duplicate and non-infected simulants from contact list
  let idTable table:make
  let fixedTable table:make
  let anyKnownContact false
  ask turtle-set (table:values infectedContactList) [
    if not table:has-key? idTable who [
      table:put idTable who 1
      if color = red [
        table:put fixedTable (table:length fixedTable) self
        if hasKnownContact [
          set anyKnownContact true
        ]
      ]
    ]
  ]
  set infectedContactList fixedTable
  
  set hasKnownContact (anyKnownContact or hasKnownContact)
  if tracked = 1 [
    simul_setContactsKnown
  ]
end

to simul_traceme
  ;; this represents the standard tracking and tracing regime - undetected people are not tracked
  ;; Symtomatic people automatically trace themselves on symtomatic_present_day of their infection (with the day of infection being day 0) 
  ifelse color = red 
  [
    if asymptomaticFlag = 0 and noticeOwnInfection = 0 and (symtomatic_present_day > -1 and timenow >= symtomatic_present_day) [
      ifelse timenow = symtomatic_present_day
      [
        set noticeOwnInfection 1
      ]
      [
        set noticeOwnInfection 0
      ]
    ]
    if tracking and tracked != 1 [
      if hasKnownContact [
        set knownContactTime -1
      ]
      if (noticeOwnInfection = 1 or hasKnownContact) and (trace_attempt_limit = -1 or traceAttempts < trace_attempt_limit) [
        set traceAttempts traceAttempts + 1
        if (noticeOwnInfection = 1)
        or (asymptomaticFlag = 1 and Asymptom_Trace_Mult * track_and_trace_efficiency * selfTraceEffMult > random-float 1)
        or (asymptomaticFlag = 0 and track_and_trace_efficiency * selfTraceEffMult > random-float 1) [
          set caseReportTime ticks + Case_Reporting_Delay
          set tracked 1
          set IDTime timenow
          
          if trace_calibration > 0 [
            if first_trace_occurred = -1 [
              set first_trace_occurred ticks
            ]
            set cumulative_tracked_all cumulative_tracked_all * extraScaleFactor * (Scale_Factor ^ scalephase)
            if noticeOwnInfection = 1 [
              set cumulative_tracked_notice cumulative_tracked_notice * extraScaleFactor * (Scale_Factor ^ scalephase)
            ]
          ]
          
          simul_setContactsKnown
          set global_trace_again true
        ]
      ]
    ]
  ]
  [
    if tracking and hasKnownContact and (trace_attempt_limit = -1 or traceAttempts < trace_attempt_limit) [
      set traceAttempts traceAttempts + 1
      if (asymptomaticFlag = 1 and Asymptom_Trace_Mult * track_and_trace_efficiency * selfTraceEffMult > random-float 1) 
      or (asymptomaticFlag = 0 and track_and_trace_efficiency * selfTraceEffMult > random-float 1) [
        simul_setContactsKnown
        set global_trace_again true
      ]
    ]
  ]
end

to simul_traceme_recursive_contact
  set knownContactTime -1
  ;; cut down contact tracing that sweeps the population looking for chains of contacts to trace in one day.
  ifelse color = red 
  [
    if tracking and tracked != 1 and (trace_attempt_limit = -1 or traceAttempts < trace_attempt_limit) [
      set traceAttempts traceAttempts + 1
      if (asymptomaticFlag = 1 and Asymptom_Trace_Mult * track_and_trace_efficiency * selfTraceEffMult > random-float 1) or (asymptomaticFlag = 0 and track_and_trace_efficiency * selfTraceEffMult > random-float 1) [
        set caseReportTime ticks + Case_Reporting_Delay
        set tracked 1
        set IDTime timenow
        simul_setContactsKnown
        set global_trace_again true
      ]
    ]
  ]
  [
    if tracking and hasKnownContact and (trace_attempt_limit = -1 or traceAttempts < trace_attempt_limit) [
      set traceAttempts traceAttempts + 1
      if (asymptomaticFlag = 1 and Asymptom_Trace_Mult * track_and_trace_efficiency > random-float 1) or (asymptomaticFlag = 0 and track_and_trace_efficiency > random-float 1) [
        simul_setContactsKnown
        set global_trace_again true
      ]
    ]
  ]
end

to trace_doTrace
  set global_trace_again false
  ask simuls [
    simul_traceme
  ]
  while [global_trace_again] [
    set global_trace_again false
    ask simuls with [knownContactTime = ticks] [
      simul_traceme_recursive_contact
    ]
  ]
end

to traceadjust
  ;; Rescale this to match 80% found at 5 cases per week.
  ifelse infectionsinperiod7 > 0
  [
    set track_and_trace_efficiency  trace_eff_base * (0.88 ^ ln(((infectionsinperiod7) / 35) ^ 2)) * traceMult
  ]
  [
    set track_and_trace_efficiency  trace_eff_base * (0.88 ^ ln((1 / 35) ^ 2)) *  traceMult
  ]
end

to test_traceadjust
  print traceMult
  set infectionsinperiod7 0
  traceadjust
  print list (infectionsinperiod7) track_and_trace_efficiency
  set infectionsinperiod7 1
  traceadjust
  print list (infectionsinperiod7) track_and_trace_efficiency
  set infectionsinperiod7 5
  traceadjust
  print list (infectionsinperiod7) track_and_trace_efficiency
  set infectionsinperiod7 10 
  traceadjust
  print list (infectionsinperiod7) track_and_trace_efficiency
  set infectionsinperiod7 35
  traceadjust
  print list (infectionsinperiod7) track_and_trace_efficiency
  set infectionsinperiod7 50
  traceadjust
  print list (infectionsinperiod7) track_and_trace_efficiency
  set infectionsinperiod7 100 
  traceadjust
  print list (infectionsinperiod7) track_and_trace_efficiency
end
