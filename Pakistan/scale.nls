
;;*******************************************************************************************************************************
;;** Recovery shifting to match global scale **
;;*******************************************************************************************************************************

to ShiftRecoveredTowardsTotalProportion
  if Recovered_Match_Rate > 0 [
    set recoverProportion recoverCount / (total_population - deathCount)
    let repYellowCount ceiling (Population * recoverProportion)
    let yellowSet simuls with [ color = yellow ]
    let yellowSetCount count yellowSet
    if repYellowCount < yellowSetCount [
      ask n-of (Recovered_Match_Rate * (yellowSetCount - repYellowCount) + random-float 1) yellowSet [
        set color cyan
        set recoveryVariant 0
        simul_updateVacAndReinfectMult
      ]
    ]
    ;if repYellowCount > yellowSetCount [
    ;  ask n-of (Recovered_Match_Rate * (repYellowCount - yellowSetCount) + random-float 1) simuls with [ color = cyan ] [
    ;    set color yellow
    ;    set recoveryVariant 1 ;; TODO this number should not always be 1 if this code is to be used. However, the code may be useless.
    ;    set isolating 0
    ;    simul_updateVacAndReinfectMult
    ;  ]
    ;]
  ]
  
  if Recov_Var_Match_Rate > 0 and recoverCount > 0 [
    let yellowSet simuls with [ color = yellow ]
    let variantKeys table:keys recoverCountByVariant
    let yellowSetCount count yellowSet
    
    ;; recoverCount may not necessarily be equal to the sum of recoverCountByVariant
    let totalRecoverByVariant 0
    foreach variantKeys [ variant ->
      set totalRecoverByVariant totalRecoverByVariant + table:get recoverCountByVariant variant
    ]
    
    ;; Cache some simulant counts
    let variantSet table:make
    let variantPropDiff table:make
    
    ;; Determine which variant is the most below the desired proportion.
    let wantMostVariant 0
    let wantMostProp 0
    foreach variantKeys [ variant ->
      let myYellow yellowSet with [recoveryVariant = variant]
      let myProp (count myYellow) / yellowSetCount
      let desiredProp (table:get recoverCountByVariant variant) / totalRecoverByVariant
      if desiredProp > myProp [
        if desiredProp - myProp > wantMostProp [
          set wantMostProp desiredProp - myProp
          set wantMostVariant variant
        ]
      ]
      if desiredProp < myProp [
        table:put variantSet variant myYellow
        table:put variantPropDiff variant (myProp - desiredProp)
      ]
    ]
    
    ;; Each variant that is above its desired proportion transfers some of its share to the
    ;; variant that has the largest shortfall.
    foreach table:keys variantPropDiff [ variant ->
      ask n-of ((table:get variantPropDiff variant) * Recov_Var_Match_Rate * yellowSetCount) table:get variantSet variant [
        set recoveryVariant wantMostVariant
      ]
    ]
  ]
  
  set recoverCount recoverCount * dailyRecoverMult
end

;;*******************************************************************************************************************************
;;** Scale Modification **
;;*******************************************************************************************************************************

to scaleup_try_to_maintain_cohort
  set scalephase scalephase + 1
  let localRedCount count simuls with [ color = red ]
  let localYellowCount count simuls with [ color = yellow ]
  let localFilter 0
  
  let R_average_before 0
  if track_R [
    let R_agg 0
    let R_count 0
    ask simuls with [ color = red ] [
      set R_agg R_agg + R
      set R_count R_count + 1
    ]
    ifelse R_count > 0 [
      set R_average_before R_agg / R_count
    ]
    [
      set R_average_before 0
    ]
  ]
  
  ;; Don't scale all yellows if a high proportion of the population has recovered.
  let yellowScaleFactor Scale_Factor
  set recoverProportion recoverCount / (total_population - deathCount)
  if recoverProportion > localYellowCount / (Population * yellowScaleFactor) [
    set yellowScaleFactor localYellowCount / (Population * recoverProportion)
    if yellowScaleFactor < 1 [
      set yellowScaleFactor 1
    ]
  ]
  
  foreach popDivisionTable_keys [ index ->
    let cohort table:get populationCohortCache index
    
    ;; random-float 1 randomly handles fractional counts. It works because ask n-of seems to round down.
    set localFilter cohort with [ color = red ]
    ask n-of (((count localFilter + random-float 1) * (1 - 1 / Scale_Factor))) localFilter [
      simul_do_scaleup
    ]
    
    set localFilter cohort with [ color = yellow ]
    ask n-of (((count localFilter + random-float 1) * (1 - 1 / yellowScaleFactor))) localFilter [
      simul_do_scaleup
    ]
  ]
  
  set localFilter simuls with [ color = red ]
  let localRedCount_after count localFilter
  if localRedCount_after * Scale_Factor > localRedCount [
    ask n-of (localRedCount_after - localRedCount / Scale_Factor + random-float 1) localFilter [
      simul_do_scaleup
    ]
  ]
  
  set localFilter simuls with [ color = yellow ]
  let localYellowCount_after count localFilter
  if localYellowCount_after * yellowScaleFactor > localYellowCount [
    ask n-of (localYellowCount_after - localYellowCount / yellowScaleFactor + random-float 1) localFilter [
      simul_do_scaleup
    ]
  ]
  
  if track_R [
    let R_agg 0
    let R_count 0
    ask simuls with [ color = red ] [
      set R_agg R_agg + R
      set R_count R_count + 1
    ]
    if R_count > 0 [
      let R_average_after R_agg / R_count
      ;;show ( word "Before " R_average_before ", After " R_average_after )
      let R_scale R_average_before / R_average_after
      ask simuls with [ color = red ] [
        set R R * R_scale
      ]
    ]
  ]
end

to scaledown_try_to_maintain_cohort
  foreach popDivisionTable_keys [ index ->
    let cohort table:get populationCohortCache index
    ask cohort with [ color = red ] [
      let my_timenow timenow
      let my_caseReportTime caseReportTime
      let my_tracked tracked
      let my_inQuarantine inQuarantine
      let my_R R
      let my_infectVariant infectVariant
      let my_variantTransMult variantTransMult
      
      let eligible cohort with [ color != red or color != black ]
      if count eligible < (Scale_Factor - 1) [
        set eligible simuls with [ color != red or color != black ]
      ]
      
      ask n-of (Scale_Factor - 1) eligible [
        set color red
        set infectVariant my_infectVariant
        set variantTransMult my_variantTransMult
        simul_updateVacAndReinfectMult

        set isolating 0
        set timenow my_timenow
        set caseReportTime my_caseReportTime
        set tracked my_tracked
        set inQuarantine my_inQuarantine
        set R my_R
        if inQuarantine = 1 [
          move-to one-of patches with [ pcolor = white ] 
        ]
      ]
    ]
  ]
  
  ;; Reset all houses so infective people are together.
  reset_housing
  set scalephase scalephase - 1
end

to-report GetInitialScale [cases]
  let caseScale floor log cases Scale_Factor
  let scaleRangeInThreshold floor log Scale_Threshold Scale_Factor
  report caseScale - scaleRangeInThreshold
end

to CheckScale
  ;; this function scales up the simulation at base Scale_Factor to enable a small and large-scale understanding of dynamics.
  ;; It enables the fine-grained analysis in early stages that more closely resembles diffusion across a population similar to
  ;; assumptions in SEIR models but as it scales up, recognises that there are geographic constraints of movement of populations
  (ifelse scale = true and redCount >= Scale_Threshold and scalePhase >= 0 and ((Scale_Factor ^ (scalePhase + 1)) * Population <= Total_Population) and days > 0
    [
      ;print count simuls with [ color = red ]
      scaleup_try_to_maintain_cohort
      ;print count simuls with [ color = red ]
    ]
    scale = true and redCount <= Scale_Threshold / Scale_Factor and yellowcount > redcount and days > 0 and scalephase > 0
    [
      scaledown_try_to_maintain_cohort
    ]
  )
end
