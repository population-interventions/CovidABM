
to ShiftRecoveredTowardsTotalProportion
  if Recovered_Match_Rate > 0 [
    set recoverProportion recoverCount / (total_population - deathCount)
    let repYellowCount ceiling (Population * recoverProportion)
    let yellowSet simuls with [ color = yellow ]
    let yellowSetCount count yellowSet
    if repYellowCount < yellowSetCount [
      let wantAsk (Recovered_Match_Rate * (yellowSetCount - repYellowCount) + random-float 1)
      if wantAsk > count yellowSet [
        set wantAsk count yellowSet 
      ]
      ask n-of wantAsk yellowSet [
        set color cyan
        set recoverTime 0
        set recoveryVariant 0
        simul_updateVacAndReinfectMult
      ]
    ]
    if repYellowCount > yellowSetCount [
      let wantAsk (Recovered_Match_Rate * (repYellowCount - yellowSetCount) + random-float 1)
      let cyanSet simuls with [ color = cyan ]
      if wantAsk > count cyanSet [
        set wantAsk count cyanSet 
      ]
      ask n-of wantAsk cyanSet [
        simul_setNewRecover
        set recoveryVariant 1 ;; TODO this number should not always be 1 if this code is to be used.
        set isolating 0
        simul_updateVacAndReinfectMult
      ]
    ]
  ]
  
  if Recov_Var_Match_Rate > 0 and recoverCount > 0 [
    let yellowSet simuls with [ color = yellow ]
    let variantKeys table:keys recoverCountByVariant
    let yellowSetCount count yellowSet
    
    ;; recoverCount may not necessarily be equal to the sum of recoverCountByVariant
    let totalRecoverByVariant 0
    foreach variantKeys [ variant ->
      set totalRecoverByVariant totalRecoverByVariant + table:get recoverCountByVariant variant
    ]
    
    ;; Cache some simulant counts
    let variantSet table:make
    let variantPropDiff table:make
    
    ;; Determine which variant is the most below the desired proportion.
    let wantMostVariant 0
    let wantMostProp 0
    if yellowSetCount > 0 [
      foreach variantKeys [ variant ->
        let myYellow yellowSet with [recoveryVariant = variant]
        let myProp (count myYellow) / yellowSetCount
        let desiredProp (table:get recoverCountByVariant variant) / totalRecoverByVariant
        if desiredProp > myProp [
          if desiredProp - myProp > wantMostProp [
            set wantMostProp desiredProp - myProp
            set wantMostVariant variant
          ]
        ]
        if desiredProp < myProp [
          table:put variantSet variant myYellow
          table:put variantPropDiff variant (myProp - desiredProp)
        ]
      ]
      
      ;; Each variant that is above its desired proportion transfers some of its share to the
      ;; variant that has the largest shortfall.
      foreach table:keys variantPropDiff [ variant ->
        ask n-of ((table:get variantPropDiff variant) * Recov_Var_Match_Rate * yellowSetCount) table:get variantSet variant [
          set recoveryVariant wantMostVariant
        ]
      ]
    ]
  ]
  
  set recoverCount recoverCount * dailyRecoverMult
end

to scale_setup
  set scalePhaseMax (Log (total_population / population) Scale_Factor)
  set scalePhaseExtra scalePhaseMax - floor scalePhaseMax
  set scalePhaseMax floor scalePhaseMax
  ;print total_population
  ;print population
  ;print Scale_Factor
  ;print scalePhaseMax
end

to-report GetUninfectedOfCohort [index wantedDoseCount wantedHomeRegion]
  let cohortSimuls (table:get populationCohortCache index) with [color != red]
  let matchDose cohortSimuls with [doseCount = wantedDoseCount]
  ifelse any? matchDose
  [
    report matchDose
  ]
  [
    let succSimuls simuls with [color != red]
    let regionSimuls succSimuls with [homeRegion = wantedHomeRegion]
    set matchDose regionSimuls with [doseCount = wantedDoseCount]
    ifelse any? matchDose
    [
      report matchDose
    ]
    [
      set matchDose succSimuls with [doseCount = wantedDoseCount]
      ifelse any? matchDose
      [
        report matchDose
      ]
      [
        report succSimuls
      ]
    ]
  ]
end

to-report GetInitialScale [cases]
  if cases = 0 [
   report 0 
  ]
  let caseScale floor log cases Scale_Factor
  let scaleRangeInThreshold floor log Scale_Up_Threshold Scale_Factor
  if caseScale - scaleRangeInThreshold > 0 [
    report caseScale - scaleRangeInThreshold 
  ]
  report 0
end
