;;
;; Setup and functions particular to setup that don't have anywhere else to live.
;;

to setEssentialWorkerPriority
  ifelse isWorker 
  [
    ifelse essentialJob
    [
      set EssentialWorkerPriority round (random-float essentialWorkerRange)
    ]
    [
      set EssentialWorkerPriority round (essentialWorkerRange + random-float otherWorkerRange)
    ]
  ]
  [
    set EssentialWorkerPriority 101 ;; People who don't work are never essential workers.
  ]
end

to loadPopDivisionTable
  let fileName (word input_population_table data_suffix)
  if data_suffix_2 != "None" [
    set fileName (word fileName data_suffix_2)
  ]
  let populationFileData remove-item 0 csv:from-file fileName
  set popDivisionTable table:make
  set popDivisionTable_keys []
  let i 0
  foreach populationFileData [ x -> 
    table:put popDivisionTable i x
    set popDivisionTable_keys lput i popDivisionTable_keys
    set i i + 1
  ]
end

to loadRegionTable
  let regionFileData remove-item 0 csv:from-file input_region
  set regionTable table:make
  set regionTable_keys []
  set regionTable_list []
  let i 0
  foreach regionFileData [ x -> 
    let region (item 0 x)
    table:put regionTable i x
    set regionTable_keys lput i regionTable_keys
    
    set regionTable_list lput region regionTable_list
    table:put endR_count region 0
    table:put endR_mean_metric region 0
    table:put endR_sum region 0
    table:put totalEndCount region 0
    table:put totalEndR region 0
    table:put average_R region 0
    
    set i i + 1
  ]
end


to processPopulationData
  let tableData table:values popDivisionTable
  let regionPopulation table:make
  
  set totalWorkers 0
  set totalEssentialWorkers 0
  foreach tableData [ data -> 
    set totalWorkers totalWorkers + item 5 data
    set totalEssentialWorkers totalEssentialWorkers + item 4 data
    let region item 10 data
    let pop item 0 data
    if not table:has-key? regionPopulation region [
      table:put regionPopulation region 0
    ]
    table:put regionPopulation region ((table:get regionPopulation region) + pop)
  ]
  
  set essentialWorkerRange 100 * totalEssentialWorkers / totalWorkers
  set otherWorkerRange 100 * (totalWorkers - totalEssentialWorkers) / totalWorkers
  
  ;; Set the house index range used by each region
  set regionHouseMin table:make
  set regionHouseMax table:make
  set regionPosMin table:make
  set regionPosMax table:make
  
  let regionTableData table:values regionTable
  let curHouseIndex 0
  foreach regionTableData [ data -> 
    let region item 0 data
    ;; Houses in the region is population / house size
    let houses ceiling ((table:get regionPopulation region) / (item 3 data))
    table:put regionHouseMin region curHouseIndex
    table:put regionHouseMax region curHouseIndex + houses
    set curHouseIndex curHouseIndex + houses
    table:put regionPosMin region (item 1 data) * world-height
    table:put regionPosMax region (item 2 data) * world-height
  ]
end

to createSimulants
  let pop_index 0
  let agentsOfThisIndex 0
  let oldCohortIndex -1
  
  let cohort_pop 0
  let cohort_age 0
  let cohort_asti 0
  let cohort_disability 0
  let cohort_essentialCount 0
  let cohort_workerCount 0
  let cohort_phase 0
  let cohort_subPhase 0
  let cohort_spanMult 0
  let cohort_gatherFreqMult 0
  let cohort_region 0
  let cohort_succeptMult 0
  let cohort_asymptomPropMult 0
  let cohort_ignoreUptakeOverride 0
  let cohort_studentCount 0
  let cohort_vaccineType 0
  let cohort_vaccineBranch 0
  let cohort_vaccineUptake 0
  let cohort_wane_1 0
  let cohort_wane_2 0
  let cohort_wane_3 0
  let cohort_riskOfDeath 0
  let cohort_riskOfHosp 0
  
  ;; set up people in the environment and allocates characteristics to them
  ask n-of (Population) patches with [ pcolor = black ] [
    
    if oldCohortIndex != pop_index [
      ; Iterate over cohort data to get each set of simul parameters.
      if not table:has-key? popDivisionTable pop_index [
        print "totalAgents in population.csv sums to less than Population (2500)." 
      ]
      let cohortData table:get popDivisionTable pop_index
      
      set cohort_pop item 0 cohortData
      set cohort_age item 1 cohortData
      set cohort_asti item 2 cohortData
      set cohort_disability item 3 cohortData
      set cohort_essentialCount item 4 cohortData
      set cohort_workerCount item 5 cohortData
      set cohort_phase item 6 cohortData
      set cohort_subPhase item 7 cohortData
      set cohort_spanMult item 8 cohortData
      set cohort_gatherFreqMult item 9 cohortData
      set cohort_region item 10 cohortData
      set cohort_succeptMult item 11 cohortData
      set cohort_asymptomPropMult item 12 cohortData
      ;; Items 13, 14 and 15 are for pre-model vaccination so are dealt with in setupInitialVaccination.
      set cohort_ignoreUptakeOverride item 16 cohortData
      set cohort_studentCount item 17 cohortData
      set cohort_vaccineType item 18 cohortData
      set cohort_vaccineBranch item 19 cohortData
      set cohort_vaccineUptake item 20 cohortData
      
      ;; Wane is a downwards slope but is entered as a positive number in input data.
      set cohort_wane_1 0 - (item 21 cohortData)
      set cohort_wane_2 0 - (item 22 cohortData)
      set cohort_wane_3 0 - (item 23 cohortData)
      
      set cohort_riskOfDeath (item 24 cohortData)
      set cohort_riskOfHosp (item 25 cohortData)
      
      if vacType_override != "off" [
        set cohort_vaccineType vacType_override
      ]
      
      if param_force_vaccine != "Disabled" [
        set cohort_vaccineType param_force_vaccine 
      ]
      
      set oldCohortIndex pop_index
    ]
    set agentsOfThisIndex agentsOfThisIndex + 1
    
    sprout-simuls 1 [
      set size 2
      set shape "dot"
      set color cyan
      set householdUnit random 1000
      set tracked 0
      set knownContactTime -1
      set timenow 0
      set noticeOwnInfection 0
      set IncubationPd int ownIncubationPeriod
      set doseCount 0
      set selfVaccEff_raw_infect 0
      set selfVaccEff_raw_risk 0
      set R 0
      set vacEffectCountdown 0
      set isolating 0
      set succeptibilityTable table:make
      set hasNewHouse false
      set vaccineIncursionOverride 0
      set update_lock false
      set isInitialInfection false
      set BeAvoided true
      
      set siteIsolating false
      
      set selfTraceEffMult 1
      set traceAttempts 0
      set caseReportTime 0
      
      set infectedContactList table:make
      set hasKnownContact false
      
      set move_chance_multiplier 2 * rngs:rnd-beta moveInitSeedID (10 / hetro_mult) (10 / hetro_mult)
      set visit_chance_multiplier 5 * rngs:rnd-beta moveInitSeedID (1 / hetro_mult) (4 / hetro_mult)
      set superSpread_chance_multiplier 6 * rngs:rnd-beta moveInitSeedID (0.6 / hetro_mult) (3 / hetro_mult)
      set personalVirulence rngs:rnd-beta moveInitSeedID (global_trans_a / hetro_mult) (global_trans_b / hetro_mult)

      set cohortIndex pop_index
      set agerange cohort_age
      set atsi cohort_asti
      set comorbidityState cohort_disability
      set essentialJob (agentsOfThisIndex <= cohort_essentialCount)
      set isWorker (agentsOfThisIndex <= cohort_workerCount)
      set isStudent (agentsOfThisIndex <= cohort_studentCount)
      set VaccPhase cohort_phase
      set VaccSubPhase cohort_subPhase
      set vaccineType cohort_vaccineType
      set vaccBranch cohort_vaccineBranch
      set cohortVacUptake cohort_vaccineUptake
      
      set wane_1 cohort_wane_1
      set wane_2 cohort_wane_2
      set wane_3 cohort_wane_3

      set riskOfDeath cohort_riskOfDeath
      set riskOfHosp cohort_riskOfHosp
      
      set spanMult cohort_spanMult
      set gatherFreqMult cohort_gatherFreqMult
      set homeRegion cohort_region
      set succeptMult cohort_succeptMult
      set ignoreUptakeOverride cohort_ignoreUptakeOverride
      
      move-to one-of patches with [ pcolor = black ]
      
      set sm_vac_uptake random-float 1
      set report_case_draw random-float 1
      set accept_isolation_draw random-float 1
      
      set asymptomatic_draw random-float 1
      set asymptomaticFlag 0
      ifelse override_asympt_table
      [
        params_setOverrideAsympt
      ]
      [
        ifelse cohort_asymptomPropMult <= 1
        [
          if asymptomatic_draw < Asymptom_Prop * cohort_asymptomPropMult [
            set asymptomaticFlag 1
          ]
        ]
        [
          if asymptomatic_draw < 1 - (1 - Asymptom_Prop) / cohort_asymptomPropMult [
            set asymptomaticFlag 1
          ]
        ]
      ]
      
      ifelse self_iso_at_peak
      [
        set symtomatic_present_day_draw floor (ownIncubationPeriod_raw + pre_present_iso + random-float 1)
      ]
      [
        set symtomatic_present_day_draw round (sympt_present_min + (rngs:rnd-beta presentInitSeedID sympt_present_a sympt_present_b) * (sympt_present_max - sympt_present_min))
      ]
      
      set rat_draw random-float 1
      set present_draw random-float 1
      set symtomatic_present_day_draw round (sympt_present_min + (rngs:rnd-beta presentInitSeedID sympt_present_a sympt_present_b) * (sympt_present_max - sympt_present_min))

      set requireICU 0
      set requireICU_draw random-float 1

      set wearsMask random 100 ;; resethealth resetincome immune_from_reinfect calculateexpenditureperday resettrust
      set returntoschool random 100

      ;;set ownComplianceWithIsolation ( exp random-normal Mcomp SComp ) ;; log transform of compliance with isolation

      simul_resetSomeRandomParams
      simul_updatePresentDay
      ;print ownIncubationPeriod_raw

      setEssentialWorkerPriority
    ]
    
    if agentsOfThisIndex >= cohort_pop [
      set pop_index pop_index + 1
      set agentsOfThisIndex 0
    ]
  ]
  
  ;; Cache the population cohorts.
  set populationCohortCache table:make
  foreach popDivisionTable_keys [ index ->
    table:put populationCohortCache index simuls with [ cohortIndex = index ]
  ]
end

to setupInitialVaccination
  if Vaccine_Available [
    foreach popDivisionTable_keys [ index ->
      let cohort table:get populationCohortCache index
      let cohortData table:get popDivisionTable index
      
      let cohort_pop item 0 cohortData
      let vaccinatedCount item 13 cohortData
      let progMin item 14 cohortData
      let progMax item 15 cohortData
      
      if cohort_pop > 0 and vaccinatedCount > 0 [
        let toVaccinateNow vaccinatedCount
        let vacPrioIncrement 1 / cohort_pop
        let vacPrio vacPrioIncrement / 2
        
        ;; Agents added to the vaccination queue first should be the ones with the most days waited.
        let doseQueueOrder 1
        let doseQueueIncrement 1 / vaccinatedCount
        
        ;; Only pre-model vaccinate someone if they would take up the vaccine.
        ;; This ensures that the final vaccinated proportion matches init_vac_uptake.
        ask cohort [
          ifelse toVaccinateNow > 0
          [
            let myVaccineData table:get vaccineParamsTable vaccineType
            let maxVaccineDoseDays item 2 myVaccineData
            let maxVaccineEffectDays item 3 myVaccineData
            let daysSinceFirst round(maxVaccineDoseDays * (progMin + (progMax - progMin) * doseQueueOrder))
            simul_vaccinate_me_force daysSinceFirst (daysSinceFirst - maxVaccineEffectDays) maxVaccineEffectDays
            set toVaccinateNow toVaccinateNow - 1
            set vacPrio vacPrio + vacPrioIncrement
            set doseQueueOrder doseQueueOrder - doseQueueIncrement
          ]
          [
            ;; Predestine people to uptake the vaccine or not
            set vaccinePriority vacPrio
            set vacPrio vacPrio + vacPrioIncrement
          ]
        ]
      ]
    ]
    
    ask simuls with [doseCount = 0] [
      simul_addToBranchQueue
    ]
  ]
end

to setGlobals
  set anxietyFactor              0
  set InfectionChange            0
  set infectionsToday            0
  set infectionsToday_acc        0
  set infectionsYesterday        0
  set five                       0
  set fifteen                    0
  set twentyfive                 0
  set thirtyfive                 0
  set fortyfive                  0
  set fiftyfive                  0
  set sixtyfive                  0
  set seventyfive                0
  set eightyfive                 0
  set ninetyfive                 0
  set InitialReserves            0
  set AverageContacts            0
  set AverageFinancialContacts   0
  set ScalePhase                 0
  set ScalePhaseMax              0
  set extraScaleFactor           1
  set Days                       0
  set CaseFatalityRate           0
  set DeathCount                 0
  set recovercount               0
  set recoverCountByVariant      table:make
  set dailyRecoverMult           0
  set recoverProportion          0
  set casesReportedToday         0
  set casesReportedToday_acc     0
  set ICUBedsRequired            0
  set scaled_Bed_Capacity        0
  set currentInfections          0
  set eliminationDate            0
  set PotentialContacts          0
  set yellowcount                0
  set redcount                   0
  set cumulativeInfected         0
  set scaledPopulation           0
  set MeanR                      0
  set EWInfections               0
  set StudentInfections          0
  set meanDaysInfected           0
  set lasttransday               0
  set lastPeriod                 0
  set casesinperiod28            0
  set casesinperiod14            0
  set casesinperiod7             0
  set infectionsinperiod7        0
  set resetDate                  0
  set cashposition               0
  set Objfunction                0
  set decisionDate               0
  set policyTriggerScale         1
  set prior0                     preSimDailyCases
  set prior1                     preSimDailyCases
  set prior2                     preSimDailyCases
  set prior3                     preSimDailyCases
  set prior4                     preSimDailyCases
  set prior5                     preSimDailyCases
  set prior6                     preSimDailyCases
  set prior7                     preSimDailyCases
  set prior8                     preSimDailyCases
  set prior9                     preSimDailyCases
  set prior10                    preSimDailyCases
  set prior11                    preSimDailyCases
  set prior12                    preSimDailyCases
  set prior13                    preSimDailyCases
  set prior14                    preSimDailyCases
  set prior15                    preSimDailyCases
  set prior16                    preSimDailyCases
  set prior17                    preSimDailyCases
  set prior18                    preSimDailyCases
  set prior19                    preSimDailyCases
  set prior20                    preSimDailyCases
  set prior21                    preSimDailyCases
  set prior22                    preSimDailyCases
  set prior23                    preSimDailyCases
  set prior24                    preSimDailyCases
  set prior25                    preSimDailyCases
  set prior26                    preSimDailyCases
  set prior27                    preSimDailyCases
  set prior28                    preSimDailyCases
  
  set start_case_threshold       init_case_threshold
  set start_day                  0
  
  set real_prior0                0
  set real_prior1                0
  set real_prior2                0
  set real_prior3                0
  set real_prior4                0
  set real_prior5                0
  set real_prior6                0

  set slope_prior0               0
  set slope_prior1               0
  set slope_prior2               0
  set slope_prior3               0
  set slope_prior4               0
  set slope_prior5               0
  set slope_prior6               0
  
  set slope                      0
  set slopeCount                 0
  set slopeSum                   0
  set slopeAverage               0
  set casesinperiod7_max         0
  set casesReportedToday_max     0
  
  set testName                   ""
  set traceMult                  1
  set global_trace_again         false
  set trace_eff_base             1
  
  set trackCount                 0
  set trackSum                   0
  set trackAverage               0
  set infectedTrackCount         0
  set infectedTrackSum           0
  set infectedTrackAverage       0
  
  set new_case_real 0
  set new_case_real_counter 0
  
  set stage4time 0
  set stage3time 0
  set stage2time 0
  set stage1btime 0
  set stage1time 0
  set casesinperiod7_min -1
  set casesReportedToday_min -1
  set casesinperiod7_final -1
  set pre_stop_day -1
  set casesinperiod7_switchTime 0
  set cumulativeInfected_switchTime 0
  
  ;; These used to be dynamic controls with conflicting variable names.
  set spatial_distance 0
  set case_isolation 0
  set quarantine 0
  set Track_and_Trace_Efficiency 0
  set stage 0
  set prev_stage -1

  set stageHasChanged 0
  set stageToday 0
  set stageYesterday 0
  set vacRestrictionEase false
  set PrimaryUpper 0
  set SecondaryLower 0
  
  set houseTrackedCaseTimeTable table:make
  set houseLocationTable table:make
  set houseStudentMoveCache table:make
  set houseStudentMoveCache_lastUpdate table:make
  set houseStudentMoveCache_staleTime 0
  
  set popDivisionTable 0 ; Table of population cohort data

  ; Number of agents that are workers and essential workers respectively.
  set totalWorkers 0
  set totalEssentialWorkers 0
  set essentialWorkerRange 0
  set otherWorkerRange 0

  set transmission_count 0
  set transmission_count_metric 0
  set transmission_sum 0
  set transmission_average 0
  
  set avoidSuccess 0
  set avoidAttempts 0
  
  ; Vaccine phase and subphase, as well as internal index and data table.
  set global_vaccineAvailible 0
  
  set incursionsSeedID 0
  set incursionPhaseIndex 0
  set incursionPhaseEndDay 0
  
  set totalOverseasIncursions 0
  set vaccineEffseedID 0
  
  set totalEndR table:make
  set totalEndCount table:make
  set endR_sum table:make
  set endR_count table:make
  set endR_mean_metric table:make
  set average_R table:make
  
  ;; log transform illness period variables
  set Illness_PeriodVariance 0
  set M 0
  set BetaillnessPd 0
  set S 0

  ;; log transform incubation period variables
  set Incubation_PeriodVariance 0
  set MInc 0
  set BetaIncubationPd 0
  set SInc 0

  ;; log transform compliance period variables
  set Compliance_PeriodVariance 0
  set MComp 0
  set BetaCompliance 0
  set SComp 0

  ;; file reading and draw handling
  set drawNumber 0
  set drawRandomSeed 0
  set drawList 0
  
  set initial_infection_R -1
  set stop_simulation false
  set R_measure_time -1
  set cumulative_tracked_all 0
  set cumulative_tracked_notice 0
  
  set infectNoVacArray_listOut []
  set infectVacArray_listOut []
  set dieArray_listOut []
  set hospArray_listOut []
  set case_listOut []
  set case7_listOut []
  set case14_listOut []
  set case28_listOut []
  set stage_listOut []
end

;;*******************************************************************************************************************************
;;** Buttons **
;;*******************************************************************************************************************************

to setup
  clear-all
  reset-ticks
  
  setGlobals
  random-seed RAND_SEED ;; Read from a behaviourSpace variable.
  
  params_readDrawTable
  params_setDrawValues

  profiler:reset
  if profile_on [
    profiler:start
  ]
  loadPopDivisionTable
  loadRegionTable
  resetAccumulators

  ;;import-drawing "Background1.png" ;; imports MSD image
  set days 0 ; used to count days

  processPopulationData
  setup_vaccineData
  setup_incursionData
  setup_DataOut
  
  set resetdate 7
  
  ;; illness period estimation using ln transform
  set Illness_Periodvariance se_Illnesspd
  set BetaIllnessPd ln (1 + (illness_PeriodVariance / illness_period ^ 2))
  set M (ln illness_period) - (BetaillnessPd / 2)
  set S sqrt BetaIllnessPd

  ;; illness period estimation using ln transform
  set Incubation_Periodvariance se_Incubation
  set BetaIncubationPd ln (1 + (incubation_PeriodVariance / incubation_period ^ 2))
  set MInc (ln incubation_period) - (BetaincubationPd / 2)
  set SInc sqrt BetaIncubationPd

  ask patches [
    set pcolor black
    set houseIndex -1
    set lastInfectionUpdate -1
    set lastUtilTime -1
    set infectionCulprit table:make
  ]
  
  ;; a beta function for testing locating many people in one place at a single time
  ask n-of Gather_Location_Count patches with [ pcolor = black ] [
    set pcolor grey
    set destination 1
  ]
  set destination_patches patches with [ destination = 1 ]

  set initial_primary ceiling (initial_primary_prop * initial_cases)
  set initial_secondary (initial_cases - initial_primary)
  
  ;; set up initial infected people
  scale_setup
  set scalephase GetInitialScale (initial_primary + initial_secondary)
  
  let popPerSimul extraScaleFactor * (Scale_Factor ^ scalephase)
  set globalPopPerSimul popPerSimul
  ;; sets up the initial date for looking at policy-changes
  
  createSimulants
  setupInitialVaccination
  
  let potentialInitCases simuls
  if init_cases_region != -1 [
    set potentialInitCases simuls with [homeRegion = init_cases_region]
  ]
  
  ask n-of ( initial_primary / popPerSimul ) potentialInitCases [
    set color red
    set isInitialInfection true
    set contributeToR false
    set infectVariant 1
    set infectedContactList table:make
    set hasKnownContact false
    set myScale scalePhase
    if random-float 1 < initial_variant_2_prop [
      set infectVariant 2
    ]
    simul_updateVacAndReinfectMult
    
    set timenow random (floor min (list init_timenow_limit ownIllnessPeriod))
    if trace_calibration > 0 [
      set cali_timenow timenow
      set cali_asymptomaticFlag asymptomaticFlag
      set cali_symtomatic_present_day symtomatic_present_day
    ]
    if random-float 1 < init_trace_prop [
      simul_applyTrace 
    ]
    simul_updatepersonalvirulence
    set infectionsToday_acc infectionsToday_acc + 1
    ;; Do not add to infection output as it makes for poor traces.
    ;array:set infectNoVacArray cohortIndex (array:item infectNoVacArray cohortIndex) + popPerSimul
  ]

  set Quarantine false
  set eliminationDate 0 ; used to identify the date of elimination where no current, unrecovered cases exist
  set spatial_distance false
  set case_isolation false

  ;; Initialise housing
  reset_housing house_init_group
  
  ;; this ensures that half the people in households with existing infections have also have an infection and prevents a big spike early-on
  let init_secondry_infect initial_secondary
  ask potentialInitCases [
    let nearSimuls (other simuls in-radius 2 with [ color = red ])
    if init_secondry_infect > popPerSimul and any? nearSimuls [
      set color red
      set isInitialInfection true
      set contributeToR false
      set infectVariant 1
      set infectedContactList table:make
      set hasKnownContact false
      set myScale scalePhase
      
      let nearSimul one-of nearSimuls
      let thisSimul self
      table:put infectedContactList table:length infectedContactList nearSimul
      ask nearSimul [
        table:put infectedContactList table:length infectedContactList thisSimul
      ]
      
      if random-float 1 < initial_variant_2_prop [
        set infectVariant 2
      ]
      if random-float 1 < init_trace_prop [
       simul_applyTrace 
      ]
      simul_updateVacAndReinfectMult
      
      set timenow random (floor min (list init_timenow_limit ownIllnessPeriod))
      set init_secondry_infect init_secondry_infect - popPerSimul
      set infectionsToday_acc infectionsToday_acc + popPerSimul
      ;; Do not add to infection output as it makes for poor traces.
      ;;array:set infectNoVacArray cohortIndex (array:item infectNoVacArray cohortIndex) + popPerSimul
    ]
  ]

  set recovercount param_recovered_prop * total_population
  table:put recoverCountByVariant 1 recovercount
  set dailyRecoverMult exp(ln(1 - yearly_recover_prop_loss) / 365)
  ask n-of ( Population * param_recovered_prop ) simuls with [color = cyan] [
    set color yellow
    set recoverTime 0
    set recoveryVariant 1
    simul_updateVacAndReinfectMult
  ]
  ;;set tracking false ;; ensures this is set to false each time the model starts
  ;;set link_switch false ;; ensures this is set to false each timme the model starts
  ;;set schoolsOpen false ;; ensures that the schools settings don't begin before the policy trigger starts
  ;;set maskPolicy false ;; that the mask policy doesn't begin before the policy trigger starts
  ;;set assignAppEss false ;; that the assigning the App to EssentialWorkers doesn't begin before the policy trigger starts
  
  setupstages ;; setting up for the MJA runs
  
  if SIM_SEED > -1 [
    ;; Optionallly change random seed for simulation to compare simulation uncertainty to draw uncertainty
    random-seed SIM_SEED
  ]
  
  ;; Output infection rates 
  if trace_print [
    test_traceadjust
  ]
end