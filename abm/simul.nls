;;
;; Simulants and functions particular to simulants that don't have anywhere else to live.
;;

breed [ simuls simul ]

simuls-own [
  R ;; the estimated RNaught of individuals
  Pace ;; the speed that the person moves around the environment
  contributeToR ;; Whether to contribute to average R reporting.

  ;; Cohort parameters
  spanMult
  gatherFreqMult
  homeRegion
  succeptMult
  ignoreUptakeOverride
  update_lock
  isInitialInfection
  cohortVacUptake
  cohortVacSuffix
  
  myScale
  
  move_chance_multiplier
  superSpread_chance_multiplier
  visit_chance_multiplier
  
  ownIllnessPeriod ;; unique illness period associated with the individual
  ownIncubationPeriod ;; unique incubation period for the person
  ownIllnessPeriod_raw ;; without vaccination
  ownIncubationPeriod_raw ;; without vaccination
  personalVirulence ;; the infectivity of the person
  nonInfectivePeriod
  Asymptomatic_Trans

  timenow ;; the number of days since initial infection
  caseReportTime ;; Day on which the case will be reported
  
  tracked ;; whether the person has been tracked by the health system
  knownContactTime ;; Time at which a contact was known, to prevent double tracing on the traced step
  asymptomaticFlag ;; indicator identifying Asymptomatic cases
  asymptomatic_draw ;; Determines whether the agent will be asymptomatic
  asymptomatic_prop ;; Proportion of people who are symptomatic
  asymptomatic_prop_mult ;; Pre-variant cohort multiplier
  symtomatic_present_day ;; When the simulant self-presents (if at all)
  symtomatic_present_day_draw ;; Store for the above for all simulants
  present_draw ;; Determines whether the agent will present
  report_case_draw ;; Draw for whether the case successfully reaches the reported counts. Note that the case still isolates regardless of whether it is reported, this is just for policy.
  accept_isolation_draw ;; Draw for accepting isolation. Use this to simulate ineffective tracking.
  
  proportion_people_avoid_draw ;; Determines whether this agent heeds avoiding at various lockdown stages

  RequireICU ;; Whether the agent requires ICU at the moment
  requireICU_draw ;; Random determiner [0, 1) of whether the agent requires ICU

  EssentialWorkerPriority ;; Value from 0 - 100 that sets priority of the job. 1 is high, 100 is low.
  EssentialWorkerFlag ;; indicator of whether the person is considered to be an essential worker under the current lockdown policy.
  BeAvoided ;; Indicator of whether this simulant should be avoided by others. 
  
  cohortIndex ;; The row of population.csv that this simulant is based on
  agerange ;; the age of the person
  atsi
  comorbidityState ;; does the person have a comorbidity
  essentialJob ;; Static indicator of whether the agent's job is most essential, which gives it higher EssentialWorkerPriority (ie closer to zero).
  isWorker
  
  recoverDay ;; Day of recovery.
  vaccineDay ;; Day of last vaccine
  prevVaccineDay ;; Day of previous vaccine
  
  recoverVaccine ;; Name of the 'vaccine' gained by recovering
  currentVaccine ;; Name of most recent vaccine
  prevVaccine ;; Name of previous vaccine, for when the new one is not yet in effect
  
  vaccBanch
  vaccReceptive
  
  incursionVaccine
  incursionVaccineDay
  vaccinePriority ;; Number that determines whether simulant will recieve a vaccination. Compared to uptake.

  infectVariant ;; Variant of SARS that I am infected with. Is > 0 iff color = red.
  recoverVariant

  wearsMask ;; for use in determining if the person wears a face mask
  wearingMask ;; identifies if the person is wearing a mask or not

  householdUnit ;; the id of the household the person belongs to
  isStudent ;; identifies if the person is a student or not
  currentVirulence ;; current virulence of the person on the day of their infection
  Imported ;; identifies imported cases
  adultsInHousehold ;; counts how many adults in a household for peole under 70
  homeLocation ;; this is where these people live
  returntoschool ;; a random number between 0 and 100 that determines whether the person will return to school (assuming they are a student) at time x

  isolateCompliant ;; Is the person currently isolating this tick (because they are succeptible and isolating, or infected and tracked)
  isolating ;; is a succeptible person supposed to be isolating?
  siteIsolating ;; is an infective person spontaneously isolating but not yet being tracked due to a site exposure.
  doSiteIsolation ;; Does the person site isolate
  siteIsolateDay ;; Which day does the person site isolate on
  noticeOwnInfection ;; Has the person noticed that they are sick and are now being tracked and isolated of their own volition?
  IDTime ;; days into infection the person is identified as a case

  infectedContactList ;; A table of who infected this simulant and infections that this simulant has caused. Bidirectional.
  hasKnownContact ;; Whether the simulant has a tracked simulant in infectedContactList
  traceAttempts ;; How many times this simulant has attempted to be traced since the start of its last/current infection.
  selfTraceEffMult ;; Trace efficacy, used for multiple retraces.
  
  ;; Debug out
  contact_events
  
  ;; Temporary variables
  hasNewHouse
]

;;*******************************************************************************************************************************
;;** Simul Utility Functions **
;;*******************************************************************************************************************************

to simul_resetlanding
  ;; now working so home locations are not in green space
  let region homeRegion
  ifelse table:has-key? houseLocationTable householdUnit 
  [
    set homeLocation table:get houseLocationTable householdUnit
  ]
  [
    move-to one-of patches with [ pcolor = black and houseIndex = -1 and
      pycor >= table:get regionPosMin region and pycor <= table:get regionPosMax region]
    let houseNumber householdUnit
    ask patch-here [
      set houseIndex houseNumber
    ]
    set homeLocation patch-here
    table:put houseLocationTable householdUnit patch-here
  ]
  
  move-to homeLocation
end

to simul_move_to_empty_patch
  let movePatch one-of neighbors with [ lastUtilTime < ticks ]
  if is-patch? movePatch [
    move-to movePatch
    ask movePatch [
      set lastUtilTime ticks
    ]
  ]
end

to simul_resetSomeRandomParams
  set proportion_people_avoid_draw random 100
  set doSiteIsolation (random-float 1) < site_iso_prop
  set siteIsolateDay 1 + random site_iso_max_day
end

to simul_applyIsolation
  move-to homelocation
  set pace 0
  set isolateCompliant 1
end

to simul_updateIsolationResponse
  set pace span * spanMult * global_distance_mult
  set isolateCompliant 0
  if accept_isolation_draw < accept_isolation_prop and not always_spread [
    if (Case_Isolation and (isolating = 1 or tracked = 1)) or (isolate_on_inf_notice and noticeOwnInfection = 1)[
      ifelse isolating = 1 and color != red
      [
        if draw_isolationCompliance * Household_Iso_Factor > random-float 1 [
          simul_applyIsolation
        ]
      ]
      [
        ;; Full strength isolation for known cases
        ifelse caseReportTime >= ticks
        [
          if draw_isolationCompliance * Infect_Iso_Factor > random-float 1 [
            simul_applyIsolation
          ]
        ]
        [
          if draw_isolationCompliance * Track_Iso_Factor > random-float 1 [
            simul_applyIsolation
          ]
        ]
      ]
    ]
    if Case_Isolation and doSiteIsolation and color = red and siteIsolateDay >= timenow [
      if draw_isolationCompliance * Track_Iso_Factor > random-float 1 [
        simul_applyIsolation
      ]
    ] 
  ]
end

to simul_setEndStats
  ;print R_measure_time
  if R_measure_time < ticks and contributeToR [
    table:put totalEndR homeRegion (table:get totalEndR homeRegion) + R
    table:put totalEndCount homeRegion (table:get totalEndCount homeRegion) + 1
    table:put endR_sum homeRegion (table:get endR_sum homeRegion) + R
    table:put endR_count homeRegion (table:get endR_count homeRegion) + 1
  ]
  if isInitialInfection [
    if initial_infection_R = -1 [
     set initial_infection_R 0 
    ]
    set initial_infection_R initial_infection_R + R
  ]
end

to simul_do_scaleup
  set size 2
  set color cyan
  set infectVariant 0

  set timenow 0
  set noticeOwnInfection 0
  set imported 0
  set tracked 0
  set hasKnownContact false
  set isolating 0
  set R 0
  
  ;move-to one-of patches with [ pcolor = black ]
  simul_resetSomeRandomParams
  
  set returntoschool random 100
end

to simul_setNewRecover
  set color yellow
end

;;*******************************************************************************************************************************
;;** Simul Once-A-Tick Functions **
;;*******************************************************************************************************************************

to simul_record_patch_infectiveness
  if color = red and currentVirulence > 0 [
    let localInfectiveness currentVirulence
    if wearingMask = 1 and Mask_Efficacy_Mult > 0 [
      set localInfectiveness (localInfectiveness * (1 - draw_maskWearEfficacy * Mask_Efficacy_Mult))
    ]
    if asymptomaticFlag = 1 [
      set localInfectiveness (localInfectiveness * Asymptomatic_Trans)
    ]
    if isolateCompliant = 1 [
      set localInfectiveness (localInfectiveness * Isolation_Transmission )
    ]
    
    ;print "currentVirulence"
    ;print currentVirulence
    ;print ownMaskEfficacy
    ;print Asymptomatic_Trans
    ;print localInfectiveness
    
    let myPatch patch-here
    let thisSimul self
    let localVariant infectVariant
    let localPatchScale myScale
    ask myPatch [
      if lastInfectionUpdate < ticks [
        set infectionList []
        set patchScale localPatchScale
        set lastInfectionUpdate ticks
        ;set infectionCulprit table:make ;; Slow, but while technically correct, unlikely to cause issues.
      ]
      if gather_loc_trans_red > 0 and destination = 1 [
        set localInfectiveness (localInfectiveness * (1 - gather_loc_trans_red))
      ]
      set infectionList lput localInfectiveness infectionList
      table:put infectionCulprit localInfectiveness thisSimul
    ]
  ]
end

to simul_update_patch_utilisation
  let myPatch patch-here
  ask myPatch [
    set lastUtilTime ticks
  ]
end

to simul_infect
  if color != red [
    let baseSuccept succeptMult
    if wearingMask = 1 and Mask_Efficacy_Mult > 0 [
      set baseSuccept baseSuccept * (1 - draw_maskWearEfficacy * Mask_Efficacy_Mult)
    ]

    let myPatch patch-here
    let localInfectionList 0
    let localInfectionCulprit 0
    let localPatchScale 0
    ask myPatch [
      if lastInfectionUpdate >= ticks [
        set localInfectionList infectionList
        set localInfectionCulprit infectionCulprit
        set localPatchScale patchScale
      ]
    ]
    
    if is-list? localInfectionList [
      foreach infectionList [ x ->
        ;print "x"
        ;print x
        if color != red [
          let succeptibility baseSuccept * x ;; TODO calculate succeptiblity based on patchVariant
          set transmission_count transmission_count + extraScaleFactor * (Scale_Factor ^ localPatchScale)
          set transmission_sum transmission_sum + succeptibility
          let infectDraw random-float 1
          
          if print_contact_events [
            let culpritSimul table:get localInfectionCulprit x
            ask culpritSimul [
              set contact_events contact_events + 1
            ]
          ]
          
          let patchVariant 0
          ask table:get localInfectionCulprit x [
            set patchVariant infectVariant
          ]
          
          ;; Replace infection with more virulent variant
          if global_incursionReplaceChance > 0 and global_incursionVariant > patchVariant [
            if global_incursionReplaceChance > random-float 1 [
              set patchVariant global_incursionVariant
            ]
          ]
          
          ;; Check against lower succeptiblity for reinfection.
          let binomChance 1 - (1 - succeptibility) ^ Daily_Infect_Binom
          if vaccine_binomCheck infectDraw succeptibility Daily_Infect_Binom [
            set succeptibility succeptibility * (vaccine_getSucceptMult patchVariant currentVaccine vaccineDay prevVaccine prevVaccineDay)
            if vaccine_binomCheck infectDraw succeptibility Daily_Infect_Binom [
              set succeptibility succeptibility * (vaccine_getSucceptMult patchVariant recoverVaccine recoverDay 0 0)
              if vaccine_binomCheck infectDraw succeptibility Daily_Infect_Binom [
                set myScale localPatchScale
                let popPerSimul extraScaleFactor * (Scale_Factor ^ myScale)
                
                ;; Add deaths and hosp at the start of infection. The counts are delayed
                ;; TODO add deaths and hosp
                ;let adjDeathRisk riskOfDeath
                ;let adjHospRisk riskOfHosp
                ;if succeptibility < 1 [
                ;  set adjDeathRisk adjDeathRisk * (AddLogOdds succeptibility vacMortChange)
                ;  set adjHospRisk adjHospRisk * (AddLogOdds succeptibility vacHospChange)
                ;]
                ;let deathRiskMean adjDeathRisk * popPerSimul
                ;let hospRiskMean adjHospRisk * popPerSimul
                ; 
                ;set deathcount deathcount + deathRiskMean
                ;array:set dieArray cohortIndex (array:item dieArray cohortIndex) + deathRiskMean
                ;array:set hospArray cohortIndex (array:item hospArray cohortIndex) + hospRiskMean
                ;
                ;; Add hosp for dynamic policy
                ;set hospToday_acc hospToday_acc + hospRiskMean
                
                ;; Set infection status
                set color red
                set contact_events 0
                set contributeToR true
                set infectVariant patchVariant
                
                simul_updateVariantParams
                
                set infectedContactList table:make
                set traceAttempts 0
                set selfTraceEffMult 1
                
                let culpritSimul table:get localInfectionCulprit x
                let culpritTracked false
                let culpritScale 0
                let thisSimul self
                table:put infectedContactList table:length infectedContactList culpritSimul
                ask culpritSimul [
                  set culpritTracked tracked
                  set culpritScale myScale
                  table:put infectedContactList table:length infectedContactList thisSimul
                ]
                set hasKnownContact (culpritTracked = 1)
                set myScale culpritScale
                
                set isolating 0
                set timenow 0
                set infectionsToday_acc infectionsToday_acc + popPerSimul
                set new_case_real_counter new_case_real_counter + popPerSimul
                ifelse true ;; TODO check if vaccinated
                [
                  array:set infectVacArray cohortIndex (array:item infectVacArray cohortIndex) + popPerSimul
                ]
                [
                  array:set infectNoVacArray cohortIndex (array:item infectNoVacArray cohortIndex) + popPerSimul
                ]
                if track_R [
                  ask culpritSimul [
                    set R R + 1
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end

to simul_move
  ;; describes the circumstances under which people can move and infect one another
  if ticks > 1 and isolateCompliant = 0 [
    ;; this is assigned per agent so day and night are not aligned across people - this is deliberate
    ifelse 0.5 * move_chance_multiplier > random-float 1
    [
      set heading random 360
      jump random-float pace
    ]
    [
      move-to homeLocation
    ]
  ]
end

to simul_visitDestination
  ;; sets up destinations where people might gather and set off superspreader events
  ;; reduces large gatherings by stage
  if isolateCompliant = 0 and Visit_Frequency * gatherFreqMult * visit_chance_multiplier > random-float 1  [
    let myRadius Visit_Radius * global_distance_mult
    if EssentialWorkerFlag and myRadius < ess_radius_anchor [
      set myRadius (myRadius + ess_radius_anchor) * 0.5
    ]
    let movePatch one-of destination_patches in-radius myRadius
    if is-patch? movePatch [
      move-to movePatch
    ]
  ]
  ;; essential workers do not have the same capacity to reduce contact as non-esssential
end

to simul_avoid
  ;; so, if the social distancing policies are on and you are distancing at this time and you are not part of an age-isolated
  ;; group and you are not an EssentialWorkerPriority, then if there is anyone near you, move away if you can.â™¦
  if isolateCompliant != 1 [
    ;; if you are an essential worker, you can only reduce your
    ;; contacts when you are not at work assuming 8 hours work, 8 hours rest, 8 hours recreation - rest doesn't count for anyone, hence it is
    ;; set at 50 on the input slider. People don't isolate from others in their household unit
    let myPPA Proportion_People_Avoid + draw_ppa_modifier
    let myPTA Proportion_Time_Avoid + draw_pta_modifier
    
    let myHouse householdUnit
    (ifelse any? other simuls-here with [ (householdUnit != myHouse and isolateCompliant = 1) ] and draw_isolationCompliance > random-float 1
      [
        simul_move_to_empty_patch
      ]
      ((not EssentialWorkerFlag) or Ess_W_Risk_Reduction > random-float 1) and Spatial_Distance = true
      and myPPA > proportion_people_avoid_draw
      and myPTA > random 100
      [
        ifelse isStudent and schoolsOpen
        [
          ;; students don't isolate from each other or their household unit
          if any? other simuls-here with [ (householdUnit != myHouse and not isStudent) and BeAvoided ] [
            simul_move_to_empty_patch
          ]
        ]
        [
          if any? other simuls-here with [ (householdUnit != myHouse) and BeAvoided ] [
            simul_move_to_empty_patch
          ]
        ]
      ]
      [
        ;; otherwise just avoid ICU (we already moved)
        simul_update_patch_utilisation
    ])
  ]
  ;;move-to patch-here ;; Snap to grid
end

to simul_superSpread
  let mySpread superspreaders
  ;if random-float 1 < 0.001 [ print (word mySpread ", " selfVaccEff_raw_risk ", " nextDoseTimer ", " nextDoseTimer)]
  if EssentialWorkerFlag and mySpread < ess_spread_anchor [
    set mySpread (mySpread + ess_spread_anchor) * 0.5
  ]
  if (isolateCompliant = 0 and mySpread * superSpread_chance_multiplier > random-float 1) or always_spread [
    move-to one-of destination_patches
  ]
end

to simul_settime
  ;; asks simuls to start counting the days since they became infected and to also possibly die
  ;; dying this way currently not implemented but done at the end of the illness period, instead
  if color = red [
    set timenow timenow + 1
    if tracked = 1 and caseReportTime = ticks and report_case_draw < report_proportion and ticks >= IGNORE_CASE_UNTIL [
      let popPerSimul extraScaleFactor * (Scale_Factor ^ myScale)
      set casesReportedToday_acc casesReportedToday_acc + popPerSimul
    ]
  ]
end

to simul_end_infection
  if color = red and timenow > ownillnessperiod [
    ;; Truncate infective period by transmis_vs_duration_skew for testing.
    if track_R [
      simul_setEndStats
    ]
    
    let popPerSimul extraScaleFactor * (Scale_Factor ^ myScale)
    if recoverVariant != 0 [
      table:put recoverCountByVariant recoverVariant ((table:get recoverCountByVariant recoverVariant) - popPerSimul)
      if table:get recoverCountByVariant recoverVariant < 0 [
        set recoverCount recoverCount - table:get recoverCountByVariant recoverVariant
        table:put recoverCountByVariant recoverVariant 0
      ]
    ]
    
    if recoverVariant = 0 [
      set recoverCount recoverCount + popPerSimul
    ]
    table:put recoverCountByVariant infectVariant ((table:get recoverCountByVariant infectVariant) + popPerSimul)
    
    if trace_calibration > 0 [
      set finished_infections finished_infections + popPerSimul
      if tracked > 0 [
        set finished_tracked finished_tracked + popPerSimul
      ]
    ]
    
    ;; May as well set color to yellow since dead and infected people have a similar effect on the simulation.
    ;; Very few people die in the low scales as a proportion of the total population.
    simul_setNewRecover
    set isInitialInfection false
    set recoverVariant infectVariant
    set infectVariant 0
  
    if print_contact_events [
      print contact_events
      set contact_events 0
    ]
    
    set R 0
    set timenow 0
    set noticeOwnInfection 0
    set requireICU 0
    set isolating 0
    set tracked 0
    set hasKnownContact false
  ]
end

to simul_EssentialWorkerID
  ;; identifies essential workers
  ifelse EssentialWorkerPriority < Essential_Workers
  [
    set EssentialWorkerFlag true
    set BeAvoided avoid_essential
  ]
  [
    set EssentialWorkerFlag false
    set BeAvoided true
  ]
end

to simul_checkMask
  ;; identifies people who waear a mask
  let myMaskWear mask_Wearing + Mask_Wear_Boost
  ifelse maskPolicy and wearsMask <= myMaskWear and patch-here != homelocation
  [
    set wearingMask 1
  ]
  [
    set wearingMask 0
  ]
end

to simul_updateHouseTrackedCase
  ;; Add and Case_Reporting_Delay <= ticks to only isolate with confirmed cases in a household.
  if color = red and tracked = 1 [
    table:put houseTrackedCaseTimeTable householdunit ticks
  ]
end

to simul_isolateAndTrackFromHouseHold
  ;; this identifies people in the system earlier because they get a test straight away having been a close contact of someone in their house
  if isolating = 1 and color = red [
    if tracked = 0 [
      set caseReportTime ticks + Case_Reporting_Delay
      simul_setContactsKnown
    ]
    set tracked 1
  ]
  
  if color != red or (color = red and tracked = 0) [
    ifelse table:get houseTrackedCaseTimeTable householdunit = ticks
    [
      if color != red [
        set isolating 1
      ]
      if color = red [
        if tracked = 0 [
          set caseReportTime ticks + Case_Reporting_Delay
          simul_setContactsKnown
        ]
        set tracked 1
      ]
    ]
    [
      set isolating 0
    ]
  ]
end
